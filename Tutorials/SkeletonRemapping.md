# Loading Skeletal Meshes over an existing Skeleton Asset

In this tutorial we are going to reuse the Mannequin Animation Blueprint with a GLTF SkeletalMesh (A ReadyPlayerMe character)

The goal is to completely substitute the original Unreal model with the glb one without losing animations: this involves assigning a specific Skeleton asset to the ReadyPlayerMe SkeletalMesh

![Result](SkeletonRemapping_Data/Intro.PNG?raw=true "Result")

## Step 0: Loading the ReadyPlayerMe model into the Character's SkeletalMeshComponent

This is probably a very easy step (something you may have done dozens of time while playing with glTFRuntime): you get a reference to the character in your level blueprint and assign a new SkeletalMesh to it.

The SkeletalMesh is a gltf asset loaded recursively (to end with a single SkeletalMesh)

![Step0_BP](SkeletonRemapping_Data/Step0_BP.PNG?raw=true "Step0_BP")

The model will be loaded correctly:

![Step0_SM](SkeletonRemapping_Data/Step0_SM.PNG?raw=true "Step0_SM")

...but in the viewport it is in T-Pose (instead of being animated) and it is facing the wrong direction

![Step0_Viewport](SkeletonRemapping_Data/Step0_Viewport.PNG?raw=true "Step0_Viewport")

## Step 1: Fixing the SkeletalMesh Forward

The wrong facing issue is caused by the Unreal convention of having the Character's forward vector pointing along the Y (instead of the X). This is a bit annoying but lucky enough we can quickly instruct the glTFRuntime loader to automatically assume the Y is the forward vector:

![Step1_BP](SkeletonRemapping_Data/Step1_BP.PNG?raw=true "Step1_BP")

Now the Character should point in the right direction (but still in T-Pose)

![Step1_Viewport](SkeletonRemapping_Data/Step1_Viewport.PNG?raw=true "Step1_Viewport")

## Step 2: Assigning the Mannequin Skeleton

it is important to always keep in mind that each SkeletalMesh in Unreal is technically mapped to two skeleton hierarchies: the SkeletonRef and the Skeleton Asset.

The SkeletonRef defines the Mesh specific bones with their positions and rotations and it is part of the SkeletalMesh Asset (something you can access via C++). The Skeleton Asset instead is used by the animation system to recognize if a SkeletalMesh is "compatible" with a specific animation (animations themselves are assigned to a Skeleton). This means that if two different SkeletalMeshes (read: with two different SkeletonRefs) ae mapped to the same Skeleton Asset they can use the same anmations.

Now our Character has its own SkeletonRef (generated by glTFRuntime based on the asset informations) and its own Skeleton Asset (generated automatically from the SkeletonRef).

Obviously this means the Mannequin animations cannot be used with our own ReadyPlayerMe Character.

Let's start by assigni it the Mannequin Skeleton Asset:

![Step2_BP](SkeletonRemapping_Data/Step2_BP.PNG?raw=true "Step2_BP")

OOps something bad happened!

![Step2_Viewport](SkeletonRemapping_Data/Step2_Viewport.PNG?raw=true "Step2_Viewport")

(please notice that the head is moving!)

The problem here is that the ReadyPlayerMe model has the root bone in the pelvis, while the Mannequin in the middle of the feet.

Let's fix this by adding a root bone:

![Step2_BP_Fix](SkeletonRemapping_Data/Step2_BP_Fix.PNG?raw=true "Step2_BP_Fix")

## Step 3: Fixing the SkeletonRef

## Step 4: Remapping bones with JSON
```json
{
	"extras":
	{
		"rpm_retargeting":
		{
			"Hips": "pelvis",
			"Spine": "spine_01",
			"Spine1": "spine_02",
			"Spine2": "spine_03",
			"Neck": "neck_01",
			"Head": "head",
			"LeftShoulder": "clavicle_l",
			"RightShoulder": "clavicle_r",
			"LeftArm": "upperarm_l",
			"RightArm": "upperarm_r",
			"LeftForeArm": "lowerarm_l",
			"RightForeArm": "lowerarm_r",
			"LeftHand": "hand_l",
			"RightHand": "hand_r",
			"LeftUpLeg": "thigh_l",
			"RightUpLeg": "thigh_r",
			"LeftLeg": "calf_l",
			"RightLeg": "calf_r",
			"LeftFoot": "foot_l",
			"RightFoot": "foot_r",
			"LeftToe_End": "ball_l",
			"RightToe_End": "ball_r",

			"LeftHandThumb1": "thumb_01_l",
			"RightHandThumb1": "thumb_01_r",
			"LeftHandThumb2": "thumb_02_l",
			"RightHandThumb2": "thumb_02_r",
			"LeftHandThumb3": "thumb_03_l",
			"RightHandThumb3": "thumb_03_r",

			"LeftHandIndex1": "index_01_l",
			"RightHandIndex1": "index_01_r",
			"LeftHandIndex2": "index_02_l",
			"RightHandIndex2": "index_02_r",
			"LeftHandIndex3": "index_03_l",
			"RightHandIndex3": "index_03_r",

			"LeftHandMiddle1": "middle_01_l",
			"RightHandMiddle1": "middle_01_r",
			"LeftHandMiddle2": "middle_02_l",
			"RightHandMiddle2": "middle_02_r",
			"LeftHandMiddle3": "middle_03_l",
			"RightHandMiddle3": "middle_03_r",

			"LeftHandRing1": "ring_01_l",
			"RightHandRing1": "ring_01_r",
			"LeftHandRing2": "ring_02_l",
			"RightHandRing2": "ring_02_r",
			"LeftHandRing3": "ring_03_l",
			"RightHandRing3": "ring_03_r",

			"LeftHandPinky1": "pinky_01_l",
			"RightHandPinky1": "pinky_01_r",
			"LeftHandPinky2": "pinky_02_l",
			"RightHandPinky2": "pinky_02_r",
			"LeftHandPinky3": "pinky_03_l",
			"RightHandPinky3": "pinky_03_r"
		}
	}
}
````

## Step 5: More complex remapping: UE5 Manny

The UE5 Manny Character has a more complex (and somewhat incompatible) Skeleton structure. The main issue is the different hierarchy (check the spine bones).

![Manny](SkeletonRemapping_Data/Step5_Manny.PNG?raw=true "Manny")

Given that 'holes in the hierarchy' are not allowed, we need to map the missing bones (like spine_04 and spine_05) to a valid parent bone (like spine_03) and assigning them an identity (empty) Transform:

```json
{
	"extras":
	{
		"rpm_retargeting":
		{
			"Hips": "pelvis",
			"Spine": "spine_01",
			"Spine1": "spine_02",
			"Spine2": "spine_03,spine_04,spine_05",
			"Neck": "neck_01,neck_02",
			"Head": "head",
			"LeftShoulder": "clavicle_l",
			"RightShoulder": "clavicle_r",
			"LeftArm": "upperarm_l",
			"RightArm": "upperarm_r",
			"LeftForeArm": "lowerarm_l",
			"RightForeArm": "lowerarm_r",
			"LeftHand": "hand_l",
			"RightHand": "hand_r",
			"LeftUpLeg": "thigh_l",
			"RightUpLeg": "thigh_r",
			"LeftLeg": "calf_l",
			"RightLeg": "calf_r",
			"LeftFoot": "foot_l",
			"RightFoot": "foot_r",
			"LeftToe_End": "ball_l",
			"RightToe_End": "ball_r",

			"LeftHandThumb1": "thumb_01_l",
			"RightHandThumb1": "thumb_01_r",
			"LeftHandThumb2": "thumb_02_l",
			"RightHandThumb2": "thumb_02_r",
			"LeftHandThumb3": "thumb_03_l",
			"RightHandThumb3": "thumb_03_r",

			"LeftHandIndex1": "index_metacarpal_l,index_01_l",
			"RightHandIndex1": "index_metacarpal_r,index_01_r",
			"LeftHandIndex2": "index_02_l",
			"RightHandIndex2": "index_02_r",
			"LeftHandIndex3": "index_03_l",
			"RightHandIndex3": "index_03_r",

			"LeftHandMiddle1": "middle_metacarpal_l,middle_01_l",
			"RightHandMiddle1": "middle_metacarpal_r,middle_01_r",
			"LeftHandMiddle2": "middle_02_l",
			"RightHandMiddle2": "middle_02_r",
			"LeftHandMiddle3": "middle_03_l",
			"RightHandMiddle3": "middle_03_r",

			"LeftHandRing1": "ring_metacarpal_l,ring_01_l",
			"RightHandRing1": "ring_metacarpal_r,ring_01_r",
			"LeftHandRing2": "ring_02_l",
			"RightHandRing2": "ring_02_r",
			"LeftHandRing3": "ring_03_l",
			"RightHandRing3": "ring_03_r",

			"LeftHandPinky1": "pinky_metacarpal_l,pinky_01_l",
			"RightHandPinky1": "pinky_metacarpal_r,pinky_01_r",
			"LeftHandPinky2": "pinky_02_l",
			"RightHandPinky2": "pinky_02_r",
			"LeftHandPinky3": "pinky_03_l",
			"RightHandPinky3": "pinky_03_r"
		},
	}
}
```

As you can see, the value of each bone mapping can constains multiple comma separated targets. This special feature instructs glTFRuntime to add more bones to the same key.

## Final Notes
